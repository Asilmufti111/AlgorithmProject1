package PhoneNetworkApp;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;
import GraphFramework.*;

/*
 *  @authors Asil, Qamar, Aroub,Khalida
 * B9A
 * CPCS-324
 * Project Code
 * 18th may. 2023
 */
public class PhNWDesignApp {

    public static void main(String[] args) throws FileNotFoundException {
        //  ======================Main======================== //
        Scanner input = new Scanner(System.in);

        // Intilize variables
        int verticesNO = 0; // number of vertices
        int edgesNO = 0; // number of edges

        // ======================Header========================//
        System.out.println("\t\t--------------------------------------------------------------------\n"
                + "\t\t|Test to Compute the Minimum Spanning Tree and Compare Running Time|\n"
                + "\t\t|For Kruskal's Algorithm & Prim's Algorithm  (With Min-heap) |\n"
                + "\t\t-------------------------------------------------------------------\n");

        System.out.println("\t\t**********  (1) Requirement 1 Using Read_from_Graph Func. ********** \n"
                + "\t\t**********  (2) Requirement 2 Using Make_Graph Func.      ********** \n");

        // ------- Read User Input for the Selected Requirement -------- //
        System.out.print("Select Requirement Option --> ");

        int userInput = input.nextInt(); // Option of the Requirement

        // make sure user enter within option
        while (userInput != 1 && userInput != 2) {
            System.out.println("Wrong Selection. ");
            System.out.print("Select Requirement Option -> ");
            userInput = input.nextInt();
        }

        // ------------------------ Requirement 1 ------------------------ //
        if (userInput == 1) {
            System.out.println("\n\n\t\t\t-Requirement 1 Using Read From Graph function-");

            File graphFile = new File("graph"); // Read from File	 
            Graph phoneLine = new Graph(); // Create An Object of Graph as CityMap
            phoneLine.readGraphFromFile(graphFile); // Access readGraphFromFile Method in Graph Class
            MSTAlgorithm MSTAlgorithm;

            // --------------------------------------------- KRUSKAL ------------------------------------------------ //
            System.out.println("\nThe phone network (minimum spanning tree) generated by Kruskal algorithm"
                    + " is as follows");

            MSTAlgorithm = new KruskalAlg(phoneLine);
            MSTAlgorithm.findMST(phoneLine); // Read Graph in Kruskal Algorithm

            MSTAlgorithm.displayResultingMST(); // Print info of MST List

            // --------------------------------------------- PQPRIM ------------------------------------------------- //
            System.out.println("\nThe phone network  (minimum spanning tree) generated by Priority-queue Prim algorithm"
                    + " is as follows:");

            MSTAlgorithm = new MHPrimAlg(phoneLine);
            MSTAlgorithm.findMST(phoneLine); // Read Graph in Prim Algorithm

            MSTAlgorithm.displayResultingMST(); // Print info of MST List

        } // End of Requirement 1

        // --------------------- Requirement 2 ------------------ //
        if (userInput == 2) {
            System.out.println("\t\t\t-Requirement 2 Using Make Graph function-");

            System.out.println("Cases of Edges(m) and Vertcies(n):");
            System.out.println("(1) n= 1000, m= 10000\n(2) n= 1000, m= 15000\n(3) n= 1000, m= 25000");
            System.out.println("(4) n= 5000, m= 15000\n(5) n= 5000, m= 25000");
            System.out.println("(6) n= 10000, m= 15000\n(7) n= 10000, m= 25000");

            // ------- Read User Input for the Selected Case -------- //
            System.out.print("Select your Test Option -> ");
            userInput = input.nextInt(); // Option of the Case

            do {
                switch (userInput) {
                    case 0: {
                        verticesNO = 4;
                        edgesNO = 6;
                    }
                    ;
                    break;
                    case 1: {
                        verticesNO = 1000;
                        edgesNO = 10000;
                    }
                    ;
                    break;

                    case 2: {
                        verticesNO = 1000;
                        edgesNO = 15000;
                    }
                    ;
                    break;
                    case 3: {
                        verticesNO = 1000;
                        edgesNO = 25000;
                    }
                    ;
                    break;
                    case 4: {
                        verticesNO = 5000;
                        edgesNO = 15000;
                    }
                    ;
                    break;
                    case 5: {
                        verticesNO = 5000;
                        edgesNO = 25000;
                    }
                    ;
                    break;
                    case 6: {
                        verticesNO = 10000;
                        edgesNO = 15000;
                    }
                    ;
                    break;
                    case 7: {
                        verticesNO = 10000;
                        edgesNO = 25000;
                    }
                    ;
                    break;

                    default:
                        System.out.println("Option not found.");
                        System.out.print("Select your Test Option -> ");
                        //      userInput = input.nextInt(); // Option of the Case
                        break;
                }
            } while (1 < 1 || 7 > 7);

            // -------- IMPORTANT NOTE -------- //
            /**
             * As we have already seen in the analysis of the algorithms, both
             * of them require an undirected graph. While inputting a directed
             * graph does not automatically stop the algorithm, few examples can
             * show why we can not allow directed graphs. So, we will only work
             * on undirected graph.
             */
            Graph phoneLine = new Graph(verticesNO, edgesNO, false); // Create An Object of Graph as CityMap 
            phoneLine.makeGraph(verticesNO, edgesNO); // Access readGraphFromFile Method in Graph Class
            MSTAlgorithm MSTAlgorithm;
            System.out.println("\n***\nP.S. All generated graphs will remain undirected.\n***\n");

            // --------------------------------------------- KRUSKAL ------------------------------------------------ //
            System.out.println("\nThe phone network (minimum spanning tree) generated by Kruskal algorithm"
                    + " is as follows");

            MSTAlgorithm = new KruskalAlg(phoneLine); // Chose Kruskal as the MST Object now
            double KruskalstartTime = System.currentTimeMillis(); // Start time of Kruskal      
            MSTAlgorithm.findMST(phoneLine); // Calculate the MST result
            double KruskalfinishTime = System.currentTimeMillis();// End time of Kruskal  
            double kruskalFinalTime = KruskalfinishTime - KruskalstartTime; // Final time  
            MSTAlgorithm.displayResultingMST();// Get the MST-Cost of Kruskal
            System.out.println("Running time  for Kruskal Algorithm: " + kruskalFinalTime);

            //--------------------------------------------- MHPRIM ------------------------------------------------- //
            System.out.println("\n\nThe phone network (minimum spanning tree) generated by Priority-queue Prim algorithm");

            MSTAlgorithm = new MHPrimAlg(phoneLine); // Chose MHPrimAlg as the MST Object now
            double MHPrimstartTime = System.currentTimeMillis();//start time of MHPrim 
            MSTAlgorithm.findMST(phoneLine); // Calculate the MST result
            double MHPrimfinishtTime = System.currentTimeMillis();//start time of MHPrim  
            double MHPrimlFinalTime = MHPrimfinishtTime - MHPrimstartTime; // Final time  
            MSTAlgorithm.displayResultingMST();// Get the MST-Cost of Prim
            System.out.println("Running time for Min-heap Prim Algorithm: " + MHPrimlFinalTime);

        } // End of if

        input.close();
        System.out.println("Build Successful.");

    } // End of Main
} // End of Class


